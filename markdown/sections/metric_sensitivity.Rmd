---
title: "Untitled"
author: "Zachary M. Smith"
date: "December 5, 2018"
output: html_document
---

# Metric Sensitivity


## Long Data Transformation

If you followed the steps above your metrics are stored in a wide data format (see `metrics.wide`); however, to simplify the metric sensitivity calculations the data needs to be transformed to a long data format. This can be easily done with the __tidyr__ (installed and loaded with __tidyverse__) function, `tidyr::gather()`. The first input variable refers to the wide data frame (`metrics.wide`). The second input specifies the name of column that will hold the current column names. The third input specifies the name of the column that will hold the values from each column. At the end of the function the key column(s) need to be dropped (`-bas_loc_rm, -condition`).
```{r}
metrics.long <- tidyr::gather(metrics.wide, metric, value, -bas_loc_rm)

DT::datatable(head(metrics.long, 500), options = list(scrollX = TRUE))
```

## Calculate Metric Sensitivity

Barbour et al. (1996) created a visual method for evaluating metric response to a defined disturbance gradient.

* 0 = The medians of both the reference and degraded conditions overlap the interquartile range of one another.
* 1 = One median (either the reference or degraded) overlaps the interquartile range of the other.
* 2 = The interquartile ranges of the reference and degraded conditions overlap but neither conditions median overlaps with the interquartile range of the other category.
* 3 = The interquartile ranges of the reference and degraded conditions do not overlap.

Discrimination Efficiency (DE) is a measure of the percentage of degraded samples correctly identified below the reference distributions 25th percentile for metrics that decrease with degradation or the percentage of degraded samples correctly identified above the reference distributions 75th percentile for metrics that increase with disturbance.

Balanced Discrimination Efficiency (BDE) attempts to update the DE method by throwing more computation power at the problem. BDE tests multiple thresholds for separating the reference and degraded distributions in an attempt to find the best separation point.

Use the `sensitivity()` function to calculate three types of metric sensitivity measures: 1) Barbour et al. (1996) method, 2) Discrimination Efficiency (DE), and 3) Balanced Discrimination Efficiency (BDE). 
```{r}
sensitivity.df <- sensitivity(metrics.long,
                              metric.col = metric,
                              value.col = value,
                              condition.col = condition,
                              ref.cond = "ref",
                              deg.cond = "test")

DT::datatable(sensitivity.df, options = list(scrollX = TRUE))
```

# Plotting

Plot Barbour et al. (1996) values greater than or equal to 2.
```{r, fig.width=8, fig.height=10}
sensitivity.df %>% 
  filter(barbour == 3) %>% 
  inner_join(metrics.long, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric))) %>% 
  filter(condition != "ot") %>% 
  ggplot(aes(condition, value)) +
  geom_boxplot() +
  facet_wrap(~metric, ncol = 4, scales = "free")
```

Plot the top 10 metrics with the best DE values.
```{r, fig.width=10}
sensitivity.df %>% 
  arrange(desc(de)) %>% 
  slice(1:10) %>% 
  inner_join(metrics.long, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric))) %>% 
  filter(condition != "ot") %>% 
  ggplot(aes(condition, value)) +
  geom_boxplot() +
  facet_wrap(~metric, ncol = 5, scale = "free")
```

Plot the top 10 metrics with the best BDE values.
```{r, fig.width= 10}
sensitivity.df %>% 
  arrange(desc(bde)) %>% 
  slice(1:10) %>% 
  inner_join(metrics.long, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric))) %>% 
  filter(condition != "ot") %>% 
  arrange(desc(bde)) %>% 
  ggplot(aes(condition, value)) +
  geom_boxplot() +
  geom_hline(aes(yintercept = bde_thresh)) +
  facet_wrap(~metric, ncol = 5, scale = "free")
```

Plot an countidual metric.
```{r}
sensitivity.df %>% 
  filter(metric == "pct_rich_heptageniidae") %>% 
  inner_join(metrics.long, by = "metric") %>% 
  filter(condition != "ot") %>% 
  arrange(desc(bde)) %>% 
  ggplot(aes(condition, value)) +
  geom_jitter()+
  geom_boxplot() +
  geom_hline(aes(yintercept = bde_thresh)) 
```


```{r}
sensitivity.df %>% 
  filter(metric == "pct_ept") %>% 
  inner_join(metrics.long, by = "metric") %>% 
  filter(condition != "ot") %>% 
  arrange(desc(bde)) %>% 
  ggplot(aes(condition, value)) +
  geom_jitter()+
  geom_boxplot() +
  geom_hline(aes(yintercept = bde_thresh)) 
```
