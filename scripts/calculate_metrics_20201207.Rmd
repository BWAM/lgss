---
title: "calculate_metrics_20201207"
output: html_document
---

# Data prep 

```{r Load libs and dirs}
library(tidyverse)
library(mmir)
# library(ggfortify)
# library(klaR) #Load this before tidyverse to avoid conflicts between MASS and dplyr
# library(rsample)
# library(recipes)
# library(parsnip)
# library(workflows)
# library(yardstick)
# library(themis)
# library(rstanarm)
# library(corrr)
# library(purrr)

root.dir <- rprojroot::find_root("lgss.Rproj")
datamod.dir <- file.path("C:/Users/gmlemley/New York State Office of Information Technology Services/SMAS - Streams Data Modernization/Cleaned Files/FINAL_RELOADS_SEPT2020")

```

```{r Master taxa table prep}
# Load master taxa table
master.taxa <- read.csv(file.path(datamod.dir, "Final_Macro_ITS", "20201019_S_MSTR_MACRO_SPECIES.csv"), stringsAsFactors = FALSE, na.strings = c("", "NA")) %>% 
  rename_all(tolower) %>% 
  setNames(., sub("mms_", "", names(.))) 

master.taxa.fill <- taxa_fill(master.taxa, .final_id = macro_genspecies, .prefix = "unidentified", kingdom:species) %>%
  mutate(ttaxa = species) %>%
  relocate(ttaxa) %>%
  rename(ffg = feeding_habits,
         tol_char = tolerance_name,
         tol_int = tolerance)

```

```{r Sample taxa table prep}

# Load bug matrix
taxa.df.wide <- read.csv(file.path(root.dir, "data/compile_2015-2019/bugs/2015-2019_lowgrad_bugs_matrix_UNIQUE_20201210.csv"), check.names = FALSE)

# List taxa names for troublshooting
# bugnames <- as.data.frame(names(taxa.df)) %>% 
#   rename(genspecies = "names(taxa.df)") %>% 
#   filter(!grepl("site_id", genspecies))

# Convert from wide to long
taxa.df <- taxa.df.wide %>% 
  gather(final_id, count, -site_id) %>% 
  filter(!is.na(count),
         count > 0)  

# Identify missing taxa
missing.df <- taxa.df %>% 
  select(final_id) %>% 
  distinct() %>% 
  anti_join(master.taxa, by = c("final_id" = "macro_genspecies"))

# Join attributes to data
taxa.df <- taxa.df %>% 
  rename(macro_genspecies = final_id) %>%
  left_join(master.taxa.fill, by = "macro_genspecies") #%>% 
  # fill_taxa(taxa.df, final_id, kingdom:subspecies)

# write.csv(taxa.df, "lowgrad_taxa_zach.csv")

rm(master.taxa, missing.df, taxa.df.wide)
```

```{r Create nested dataframe}
nest.df <- taxa.df %>%
  group_nest(site_id, .key = "data")

```

# Calculate metrics

```{r Tolerance Metric (HBI)}

# Spot-check: not completed

taxa_tol.df <- nest.df %>%
  mutate(
    hbi_taxa_tol = taxa_tol_index(.dataframe = .,
                                    .key_col = site_id,
                                    .counts_col = count,
                                    .tol_col = tol_int,
                                    .unnest_col = data)
  ) %>% 
  select(-data)

```



## Richness Metrics

```{r Standard Richness}

# Spot check: OK

rich_std.df <- nest.df %>% 
  mutate(
    # Class level richness
    rich_class = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = class,
                            .unnest_col = data),
    # Order level richness
    rich_order = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = order,
                            .unnest_col = data),
    # Family level richness
    rich_family = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = family,
                            .unnest_col = data),
    # Genus level richness
    rich_genus = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = genus,
                            .unnest_col = data),
    # Target taxon level richness
    rich_ttaxa = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .unnest_col = data),
    # Functional Feeding group richness
    rich_ffg = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ffg,
                            .unnest_col = data,
                            .filter = !is.na(ffg)),
    # Tolerance value richness
    rich_tol = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = tol_char,
                            .unnest_col = data,
                            .filter = !is.na(tol_char))
  ) %>% 
  select(-data)

```

```{r Subgroup Richness}

# Spot-check: OK

rich_subgr.df <- nest.df %>%
  mutate(
    rich_ttaxa_ep = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = order %in% c("ephemeroptera",
                                                       "plecoptera"),
                            .unnest_col = data),
    rich_ttaxa_et = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = order %in% c("ephemeroptera",
                                                       "trichoptera"),
                            .unnest_col = data),
    rich_ttaxa_pt = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = order %in% c("plecoptera",
                                                       "trichoptera"),
                            .unnest_col = data),
    rich_ttaxa_ept = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = order %in% c("ephemeroptera",
                                                       "plecoptera",
                                                       "trichoptera"),
                            .unnest_col = data),
    # Zach said this is usually specific to lakes, but keep it. May be good for LG.
    rich_ttaxa_cote = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = order %in% c("coleoptera",
                                                  "odonata",
                                                  "trichoptera",
                                                  "ephemeroptera"),
                            .unnest_col = data),
    rich_ttaxa_cot = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = order %in% c("coleoptera",
                                                  "odonata",
                                                  "trichoptera"),
                            .unnest_col = data),
    # Below Metrics were in old LG metrics script
    rich_ttaxa_toe = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = order %in% c("trichoptera",
                                                   "odonata",
                                                   "ephemeroptera"),
                            .unnest_col = data),
    rich_ttaxa_potec = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = order %in% c("plecoptera",
                                                   "odonata",
                                                   "trichoptera",
                                                   "ephemeroptera",
                                                   "coleoptera"),
                            .unnest_col = data),
    rich_ttaxa_mol = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = phylum %in% "mollusca",
                            .unnest_col = data),
     # Already done in taxa_seq() chunk, but used to calculate subgr
    rich_ttaxa_amphi = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = order %in% "amphipoda",
                            .unnest_col = data),
    rich_ttaxa_mol_amph = rich_ttaxa_mol + rich_ttaxa_amphi,
    rich_ttaxa_crust = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = subphylum %in% "crustacea",
                            .unnest_col = data),
    rich_ttaxa_mol_crust = rich_ttaxa_crust + rich_ttaxa_mol,
    rich_ttaxa_chironominae = taxa_rich(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .filter = subfamily %in% "chironominae",
                            .unnest_col = data),
    # Richness of intolerant and facultative Taxa 
    rich_ttaxa_intol_facul = taxa_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = tol_int <=6,
                             .unnest_col = data)
  ) %>% 
  select(-data)

# rich_subgr.df %>%
#   mutate(data = "nested dataframe") %>%
#   head() %>%
#   knitr::kable()
```

```{r Percent Richness}

# Spot check: not completed

rich_pct.df <- nest.df %>% 
  mutate(
     pct_rich_ttaxa_ep = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = order %in% c("ephemeroptera", 
                                                    "plecoptera"),
                             .unnest_col = data),
     pct_rich_ttaxa_et = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = order %in% c("trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data), 
     pct_rich_ttaxa_pt = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = order %in% c("trichoptera",
                                                    "plecoptera"),
                             .unnest_col = data), 
     pct_rich_ttaxa_ept = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = order %in% c("plecoptera",
                                                    "trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data), 
     pct_rich_ttaxa_toe = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = order %in% c("odonata",
                                                    "trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data), 
     pct_rich_ttaxa_cote = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = order %in% c("coleoptera",
                                                    "odonata",
                                                    "trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data),
     pct_rich_ttaxa_cot = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = order %in% c("coleoptera",
                                                    "odonata",
                                                    "trichoptera"),
                             .unnest_col = data),
     pct_rich_ttaxa_potec = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = order %in% c("plecoptera",
                                                    "coleoptera",
                                                    "odonata",
                                                    "trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data), 
     pct_rich_ttaxa_mol = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = phylum %in% "mollusca",
                             .unnest_col = data), 
     pct_rich_ttaxa_crust = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = subphylum %in% "crustacea",
                             .unnest_col = data), 
     pct_rich_ttaxa_chironominae = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = subfamily %in% "chironominae",
                             .unnest_col = data),
    # Percent Richness of Intolerant and Facultative Taxa
     pct_rich_ttaxa_intol_facul = taxa_pct_rich(.dataframe = .,
                             .key_col = site_id,
                             .group_col = ttaxa,
                             .filter = tol_int <=6,
                             .unnest_col = data)
  ) %>% 
  select(-data)

```


## Diversity Metrics

```{r Community Diversity}

### Not spot-checked

div.df <- nest.df %>%
  mutate(
    shannon_ttaxa = taxa_div(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .group_col = ttaxa,
                             .job = "shannon",
                             .base_log = 2,
                             .unnest_col = data),
    simpson_ttaxa = taxa_div(.dataframe = .,
                             .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .job = "simpson",
                            .unnest_col = data),
    margalef_ttaxa = taxa_div(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .job = "margalef",
                            .unnest_col = data),
    menhinick_ttaxa = taxa_div(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .job = "menhinick",
                            .unnest_col = data),
    pielou_ttaxa = taxa_div(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .job = "pielou",
                            .unnest_col = data),
  ) %>% 
  select(-data)

# div.df %>%
#   mutate(data = "nested dataframe") %>%
#   head() %>%
#   knitr::kable()
```

```{r Subgroup Diversity}

# Not spot-checked
# Changed group_col from order to ttaxa. Output differences were large.

div_subgr.df <- nest.df %>%
  mutate(
    gini_simpson_ttaxa_ept = taxa_div(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .filter = order %in% c("ephemeroptera",
                                                   "plecoptera",
                                                   "trichoptera"),
                            .job = "gini_simpson",
                            .unnest_col = data),
    simpson_ttaxa_ept = taxa_div(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .filter = order %in% c("ephemeroptera",
                                                   "plecoptera",
                                                   "trichoptera"),
                            .job = "simpson",
                            .unnest_col = data),
    # Simpson Diversity of Coleoptera, Odonata, and Trichoptera Genus-Species
    simpson_ttaxa_cot = taxa_div(.data = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .counts_col = count,
                            .filter = order %in% c("coleoptera",
                                                   "odonata",
                                                   "trichoptera"), 
                            .job = "simpson",
                            .unnest_col = data),
    shannon_ttaxa_ept = taxa_div(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .filter = order %in% c("ephemeroptera",
                                                   "plecoptera",
                                                   "trichoptera"),
                            .job = "shannon",
                            .base_log = 2,
                            .unnest_col = data),
    # Shannon Diversity of Coleoptera, Odonata, and Trichoptera Genus-Species
    shannon_ttaxa_cot = taxa_div(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .counts_col = count,
                            .filter = order %in% c("coleoptera",
                                                   "odonata",
                                                   "trichoptera"), 
                            .job = "shannon",
                            .base_log = 2,
                            .unnest_col = data),    
    # Shannon Diversity of Intolerant and Facultative Taxa
    shannon_ttaxa_intol_facul = taxa_div(.dataframe = .,
                            .key_col = site_id,
                            .group_col = ttaxa,
                            .counts_col = count,
                            .filter = tol_int <=6,
                            .job = "shannon",
                            .base_log = 2,
                            .unnest_col = data)
  ) %>% 
  select(-data)

# div_subgr.df %>%
#   mutate(data = "nested dataframe") %>%
#   head() %>%
#   knitr::kable()
```

```{r Dominance}

### Not spot-checked

dom.df <- nest.df %>%
  mutate(
    dom_1_ttaxa = taxa_dom(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .dom_level = 1,
                            .unnest_col = data),
    dom_2_ttaxa = taxa_dom(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .dom_level = 2,
                            .unnest_col = data),
    dom_3_ttaxa = taxa_dom(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .dom_level = 3,
                            .unnest_col = data),
    dom_4_ttaxa = taxa_dom(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .dom_level = 4,
                            .unnest_col = data),
    dom_5_ttaxa = taxa_dom(.dataframe = .,
                            .key_col = site_id,
                            .counts_col = count,
                            .group_col = ttaxa,
                            .dom_level = 5,
                            .unnest_col = data)
  ) %>% 
  select(-data)

# dom.df %>%
#   mutate(data = "nested dataframe") %>%
#   head() %>%
#   knitr::kable()
```


## Community Metrics

```{r Percentages}

# Spot-checked okay

pct.df <- nest.df %>% 
  mutate(
     pct_ep = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = order %in% c("ephemeroptera", 
                                                    "plecoptera"),
                             .unnest_col = data),
     pct_et = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = order %in% c("trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data), 
     pct_pt = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = order %in% c("trichoptera",
                                                    "plecoptera"),
                             .unnest_col = data), 
     pct_ept = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = order %in% c("plecoptera",
                                                    "trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data), 
     pct_toe = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = order %in% c("odonata",
                                                    "trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data), 
     pct_cote = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = order %in% c("coleoptera",
                                                    "odonata",
                                                    "trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data),
     pct_cot = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = order %in% c("coleoptera",
                                                    "odonata",
                                                    "trichoptera"),
                             .unnest_col = data),
     pct_potec = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = order %in% c("plecoptera",
                                                    "coleoptera",
                                                    "odonata",
                                                    "trichoptera",
                                                    "ephemeroptera"),
                             .unnest_col = data), 
     pct_mol = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = phylum %in% "mollusca",
                             .unnest_col = data), 
     pct_crust = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = subphylum %in% "crustacea",
                             .unnest_col = data), 
     pct_chironominae = taxa_pct(.dataframe = .,
                             .key_col = site_id,
                             .counts_col = count,
                             .filter = subfamily %in% "chironominae",
                             .unnest_col = data)
  ) %>% 
  select(-data)
# pct.df %>%
#   mutate(data = "nested dataframe") %>%
#   head() %>%
#   knitr::kable()

```


## Sequence Metrics

```{r}

seq.df <- nest.df %>%
  # Append all of the results as columns to a single DF.
  bind_cols(
    # Sequence through ttaxa for each unique column specified in the .filter_cols_vec.
    taxa_seq(.data = .,
             .key_col = site_id,
             # .counts_col = count,
             .filter_cols_vec = c("class",
                                  "order",
                                  "family",
                                  "tol_char",
                                  "ffg"),
             .group_col = ttaxa,
             .job = "rich",
             .exclude_pattern = "unidentified",
             .unnest_col = data),
    # Sequence through each unique column specified in the .filter_cols_vec 
    # to calculate ttaxa percent richness.
    taxa_seq(.data = .,
             .key_col = site_id,
             # .counts_col = count,
             .filter_cols_vec = c("class",
                                  "order",
                                  "family",
                                  "tol_char",
                                  "ffg"),
             .group_col = ttaxa,
             .job = "pct_rich",
             .exclude_pattern = "unidentified",
             .unnest_col = data),
    taxa_seq(.data = .,
             .key_col = site_id,
             .counts_col = count,
             .filter_cols_vec = c("class",
                                  "order",
                                  "suborder",
                                  "family",
                                  "genus",
                                  "tol_char",
                                  "ffg"),
             .job = "pct",
             .exclude_pattern = "unidentified",
             .unnest_col = data),
    # Spot-checked that manual pct_amphi came out the same as pct_NULL_amphipoda (produced by below)
    taxa_seq(.data = .,
             .key_col = site_id,
             .counts_col = count,
             .filter_cols_vec = c("class",
                                  "order", 
                                  "family",
                                  "tol_char",
                                  "ffg"),
             .group_col = ttaxa,
             .base_log = 2,
             .job = "shannon",
             .exclude_pattern = "unidentified",
             .unnest_col = data),
    taxa_seq(.data = .,
             .key_col = site_id,
             .counts_col = count,
             .filter_cols_vec = c("class",
                                  "order", 
                                  "family",
                                  "tol_char",
                                  "ffg"),
             .group_col = ttaxa,
             .job = "simpson",
             .exclude_pattern = "unidentified",
             .unnest_col = data)
  ) %>% 
  select(-data)

seq.names <- as.data.frame(names(seq.df))

```



## Combine metrics dataframes

```{r}
# metrics.all <- div_subgr.df %>%
#   left_join(div.df) %>% 
#   left_join(dom.df) %>% 
#   left_join(rich_std.df) %>% 
#   left_join(rich_pct.df) %>% 
#   left_join(pct.df) %>% 
#   left_join(rich_subgr.df) %>% 
#   left_join(taxa_tol.df) %>% 
#   left_join(seq.df)

# Cleaner way to join
metrics.df <- list(div_subgr.df,
                     div.df,
                     dom.df,
                     rich_std.df,
                     rich_pct.df,
                     pct.df,
                     rich_subgr.df,
                     taxa_tol.df,
                     seq.df) %>% 
  plyr::join_all(by = c("site_id"))

metrics.names <- names(metrics.df)
metrics.names.df <- as.data.frame(metrics.names, col.names = c("metrics", "x"))

# Invesitage rich_ffg issues
# metrics.df.rich_ffg <- metrics.df %>% 
#   select(site_id, condition_class, rich_ffg)
# Checks out OK


# Look for dups
# metrics.dups <- metrics.names.df %>%
#   mutate(n = n()) %>%
#   group_by(metrics.names) %>%
#   filter(n>1)
# 
#   group_by(accession) %>%
#   mutate(n = n()) %>%
#   filter(n > 1)
# 
# metrics.dups %>% janitor::get_dupes(metrics.all)
# 
# # library(digest)
# test <- metrics.all[!duplicated(lapply(metrics.all, digest::digest))]


# Attach disturbance categories
condition <- read.csv(file.path("C:/Data/LGSS_scripting/lgss/data/compile_2015-2019/condition_classes", "2015-2019_LG_condclasses_20201216.csv")) %>% 
  select(-PC1)

metrics.df <- metrics.df %>%
  left_join(., condition) %>% 
  select(site_id, condition_class, everything()) #%>% 
  # filter(!is.na(condition_class))

# Investigate certain metrics
# metrics.sub <- metrics.all %>% 
#   select(site_id, pct_amphi, pct_NULL_amphipoda)

```

```{r Clean up workspace, eval=FALSE}
rm(master.taxa.fill,
   taxa.df,
   nest.df,
   div_subgr.df,
   div.df,
   dom.df,
   rich_std.df,
   rich_pct.df,
   pct.df,
   rich_subgr.df,
   taxa_tol.df,
   seq.df,
   seq.names,
   condition)
```


## PMA calculation

Percent Model Affinity of Orders - (PMA-O) Is a measure of order level similarity to a model based
on the reference streams Novak and Bode (1992).
```{r, eval = TRUE}

  ##    Calculate the numbers below PMA calculation chunk below
#### Look at biomonitoring SOP to see which groups to use for Streams (change in both chunks)

metrics.df <- metrics.df %>% 
    mutate(PMA_clitellata = 4.06,
           PMA_ephemeroptera = 9.96,
           PMA_plecoptera = 0.138,
           PMA_coleoptera = 6.18,
           PMA_trichoptera = 3.89,
           PMA_chironomidae = 42.8,
           PMA_other = 33.0
    ) %>% 
  group_by(site_id) %>% 
  mutate(pct_other = sum(pct_clitellata, pct_ephemeroptera, pct_plecoptera, pct_coleoptera, pct_trichoptera, pct_chironomidae)) %>% 
  mutate(pct_other= 100-pct_other) %>% 
  ungroup() %>% 
  mutate(PMA_value_clitellata= case_when(
    PMA_clitellata < pct_clitellata ~ PMA_clitellata,
    PMA_clitellata > pct_clitellata ~ pct_clitellata,
  )) %>% 
  mutate(PMA_value_ephemeroptera= case_when(
    PMA_ephemeroptera < pct_ephemeroptera ~ PMA_ephemeroptera,
    PMA_ephemeroptera > pct_ephemeroptera ~ pct_ephemeroptera,
  )) %>% 
  mutate(PMA_value_plecoptera= case_when(
    PMA_plecoptera < pct_plecoptera ~ PMA_plecoptera,
    PMA_plecoptera > pct_plecoptera ~ pct_plecoptera,
  )) %>% 
  mutate(PMA_value_coleoptera= case_when(
    PMA_coleoptera < pct_coleoptera ~ PMA_coleoptera,
    PMA_coleoptera > pct_coleoptera ~ pct_coleoptera,
  )) %>%   
  mutate(PMA_value_trichoptera= case_when(
    PMA_trichoptera < pct_trichoptera ~ PMA_trichoptera,
    PMA_trichoptera > pct_trichoptera ~ pct_trichoptera,
  )) %>% 
  mutate(PMA_value_chironomidae= case_when(
    PMA_chironomidae < pct_chironomidae ~ PMA_chironomidae,
    PMA_chironomidae > pct_chironomidae ~ pct_chironomidae,
  )) %>% 
  mutate(PMA_value_other= case_when(
    PMA_other < pct_other ~ PMA_other,
    PMA_other > pct_other ~ pct_other,
  )) %>% 
  group_by(site_id) %>% 
  mutate(PMA = sum(PMA_value_clitellata, PMA_value_ephemeroptera, PMA_value_plecoptera, PMA_value_coleoptera, PMA_value_trichoptera, PMA_value_chironomidae, PMA_value_other)) %>% 
  ungroup() %>% 
  select(-c(PMA_value_clitellata, PMA_value_ephemeroptera, PMA_value_plecoptera, PMA_value_coleoptera, PMA_value_trichoptera, PMA_value_chironomidae, PMA_value_other))

```



# Modeling and filtering


```{r Split into training and test (validation) datasets}

library(tidymodels)

# Keep the set.seed number the same to get the same subsampled traning dataset for each run. (Change this to create a new training dataset)
set.seed(80)
train_test_split <- metrics.df %>% 
  # mutate(condition_class = factor(condition_class, levels = c("1","3","4","2"))) %>% 
  # filter(condition_class %in% c("1", "3")) %>%
  rsample::initial_split(strata = condition_class)

# Create training dataset
train.df <- training(train_test_split) %>% 
  filter(condition_class %in% c("1", "3")) 

# Create testing dataset
test.df <- testing(train_test_split) %>% 
  filter(condition_class %in% c("1", "3"))

```

```{r PMA percent comp, eval=FALSE}

### Determining percent composition of each major group for PMA calculation above

train.df.PMA <- train.df %>% 
  filter(condition_class == "1") %>% 
  group_by(site_id) %>% 
  select(site_id, 
         pct_clitellata,   #Represents Oligochaeta
         pct_ephemeroptera, 
         pct_plecoptera, 
         pct_coleoptera, 
         pct_trichoptera,
         pct_chironomidae)  %>% 
  mutate(other = sum(pct_clitellata, pct_ephemeroptera, pct_plecoptera, pct_coleoptera, pct_trichoptera, pct_chironomidae)) %>% 
  mutate(other= 100-other) %>% 
  ungroup() %>% 
  summarise_all(list(mean))


### Could also calculate PMA for FFG Composition (PMA-FFG)

```

Not necessary because of even split we do using training and testing functions. 
```{r Kolmogorov Mmirnov K-S Test, eval=FALSE}

## Kolmogorov Mmirnov K-S Test to ensure equal distribution of "condition" in training and calibration sets 
## Noted in Blocksom, 2009

### Not necessary because of even split we do using training and testing functions. 


# PULL IN DATA and replace below
all_abiotic_classified <- read_csv(file.path("C:/Data/LGSS_scripting/lgss/data/compile_2015-2019/condition_classes",
                                             "2015-2019_LG_condclasses_20201216.csv")) %>%
  select(site_id, PC1)  

test.df.sites<-test.df %>% 
  select(uniqueid)
test.df.pc1<-left_join(test.df.sites, all_abiotic_classified, by=c("uniqueid"))

train.df.sites<-train.df %>% 
  select(uniqueid)
train.df.pc1<-left_join(train.df.sites, all_abiotic_classified, by=c("uniqueid"))


ks.test(train.df.pc1$PC1, test.df.pc1$PC1)

```


```{r Calculate Sensitivity and filter}

# For full dataset
# long.all.df <- metrics.df %>% 
#   pivot_longer(cols = c(-condition_class, -site_id),
#                names_to = "metric",
#                values_to = "value")
# 
# sens.all.df <- mmir::sensitivity(.dataframe = long.all.df,
#                               .metric_col = metric,
#                               .value_col = value,
#                               .condition_col = condition_class,
#                               .reference = "1",
#                               .degraded = "3") 

# For training dataset
long.df <- train.df %>% 
  pivot_longer(cols = c(-condition_class, -site_id),
               names_to = "metric",
               values_to = "value")

sens.df <- mmir::sensitivity(.dataframe = long.df,
                              .metric_col = metric,
                              .value_col = value,
                              .condition_col = condition_class,
                              .reference = "1",
                              .degraded = "3") 

DT::datatable(sens.df, options = list(scrollX = TRUE))

sensitive_mets.vec <- sens.df %>% 
  filter(barbour >= 2) %>% 
  # Shull et al., ,2019 uses >70%
  filter(de >= 65) %>%
  pull(metric)

# Creating training dataset
train_sensitive.df <- train.df %>% 
  select(condition_class, all_of(sensitive_mets.vec)) %>% 
  mutate(condition_class = as.character(condition_class))

# Creating cross-validation set. Comes into play later during validation...
train_10cv.df <- train_sensitive.df %>% 
  rsample::vfold_cv(v = 10, repeats = 1, strata = condition_class)


# Creating testing dataset
test_sensitive.df <- test.df %>% 
  select(condition_class, all_of(sensitive_mets.vec)) %>% 
  mutate(condition_class = as.character(condition_class))

test_10cv.df <- test_sensitive.df %>% 
  rsample::vfold_cv(v = 10, repeats = 1, strata = condition_class)

# Look at FFG metrics: "predator"  "gatherer"  "shredder"  "filterer"  "scraper"   "collector"
sens.df.ffg <- sens.df %>% 
  filter(grepl("predator|gatherer|shredder|filterer|scraper|collector", metric))
```


```{r Range filtering}

sens.df.subset<-train.df %>% 
  select(site_id, condition_class, all_of(sensitive_mets.vec))

# Find mins and maxes
sens.df.subset.range<-sens.df.subset %>%
  select(-condition_class) %>% 
  summarise_at(vars(-site_id), range) %>%
  rownames_to_column() %>%
  rename(summary_stat=rowname) %>% 
   mutate(summary_stat = case_when(
     summary_stat == 1 ~ "min",
     summary_stat == 2 ~ "max"))

# Transform, calculate ranges, and categorize
range <- sens.df.subset.range %>%
  gather(metric, value, -summary_stat) %>% 
  spread(summary_stat, value) %>% 
  mutate(range = max - min) %>%
  mutate(metric_type = case_when(
    grepl("pct", metric) ~ "pct",
    grepl("dom", metric) ~ "pct",
    grepl("rich", metric) ~ "rich",
    grepl("shannon", metric) ~ "div",
    grepl("margalef", metric) ~ "div",
    grepl("simpson", metric) ~ "div",
    grepl("pielou", metric) ~ "div",
    grepl("menhinick", metric) ~ "div",
    TRUE ~ "MISSING"
  )) 

# Drop pct metrics >10, richness >5, div >1 (as per Matt. Refs?)
rangefail.pct <- range %>% 
  filter(metric_type == "pct",
         range <  10)
rangefail.rich <- range %>% 
  filter(metric_type == "rich",
         range <  5)
rangefail.div <- range %>% 
  filter(metric_type == "div",
         range < 1)

metrics.drop.range <- bind_rows(rangefail.pct, rangefail.rich, rangefail.div) %>% 
  pull(metric) %>% 
  unique()

rm(rangefail.pct, rangefail.rich, rangefail.div)

# sens.df.subset.mean<-sens.df.subset %>%
#   select(-condition_class) %>% 
#   summarise_at(vars(-site_id), mean) %>%
#   rownames_to_column() %>%
#   rename(summary_stat=rowname) %>% 
#    mutate(summary_stat = case_when(
#      summary_stat== 1 ~ "mean"))
# 
# 
# sens.df.subset.IQR<-sens.df.subset %>%
#    filter(condition_class=="1") %>% 
#   select(-condition_class) %>% 
#   summarise_at(vars(-site_id), IQR) %>%
#   rownames_to_column() %>%
#   rename(summary_stat=rowname) %>% 
#    mutate(summary_stat = case_when(
#      summary_stat== 1 ~ "IQR"))
```



```{r Similarity across sites}
#Determine which metrics have >50% same values across all sites. Picks out metrics that have poor ability to differentiate btw sites.
  # Different from filtering by range b/c could have high range but many similar output values (poor differentiation). 
# Matt reference?

sens.df.subset.long<-sens.df.subset %>% 
  select(-condition_class) %>% 
  pivot_longer(!site_id, names_to = "metric", values_to="value")

sens.df.rank<-sens.df %>% 
  unite("rank",metric, barbour, de, disturbance, sep = "_", remove = FALSE) %>% 
  select(rank, metric)

sens.df.subset.long<-left_join(sens.df.subset.long, sens.df.rank, by=c("metric"))

# sens.df.subset.wide<-sens.df.subset.long %>% 
#   select(-metric) %>% 
#   rename(metric=rank) %>% 
#   pivot_wider(names_from = metric, values_from = value)

sens.df.subset.long.round<-sens.df.subset.long %>% 
  mutate(value = case_when(
    str_detect(metric, "rich_") ~ round(value, digits = 0),
    str_detect(metric, "pct_") ~ ceiling(value),
    str_detect(metric, "shannon_") ~ round(value, digits = 1),
    str_detect(metric, "simpson_") ~ round(value, digits = 1),
    str_detect(metric, "margalef_") ~ round(value, digits = 1),
    str_detect(metric, "menhinick_") ~ round(value, digits = 1),
    str_detect(metric, "pielou_") ~ round(value, digits = 1),
    str_detect(metric, "dom_") ~  ceiling(value),
    TRUE ~ value
    
  ))

sens.df.subset.long.count <-sens.df.subset.long %>%
  group_by(metric, value) %>% 
  count(value) %>%
  ungroup() %>% 
  mutate(n_samples = 40) %>% 
  mutate(percent_similar = ((n/n_samples)*100)) %>% 
  group_by(metric, percent_similar) %>% 
  filter(percent_similar>=50)

metrics.drop.sim <- sens.df.subset.long.count %>% 
  pull(metric)

# redund.metrics <-  sens.df.subset.long.count %>% 
#   pull(metric) %>% 
#   unique()
# cat(redund.metrics, sep = ", ")
```


Relative scope of impairment (SOI) looks at variability of metrics for ref sites. If varies by more than IQR, then potentially not a good metric bc too much variability among reference sites compared to the range of impairment.

Calculated as the ratio of the IQR of reference sites and the range of possible impairment (values beyond the poorer quality 25th percentile). Relative SOI values greater than 1 indicate too much variability among reference sites compared to the range of impairment. (See Blocksom 2002, 2009 (uses reverse equation))
```{r SOI}

# Take metrics that pass 1st screening (barbour >2 & DE >70%), Filter to ref, combine metric name and predicted response (increase/decrease), take lower 25% for decrease, take top 75% for increase, take IQR

reference_sites<-sens.df.subset %>% 
  filter(condition_class =="1") %>% 
  select(site_id)
reference.vec<-c(reference_sites$site_id)

SOI.df<-sens.df.subset.long %>%
  filter(site_id %in% c(reference.vec)) %>% 
  group_by(metric) %>% 
  mutate(Q1 = case_when(
    str_detect(rank, "_decrease") ~ quantile(value, probs = 0.25),
    str_detect(rank, "_increase") ~ quantile(value, probs = 1),
    TRUE ~ value
  )) %>% 
  mutate(Q2 = case_when(
    str_detect(rank, "_decrease") ~ quantile(value, probs = 0),
    str_detect(rank, "_increase") ~ quantile(value, probs = 0.75),
    TRUE ~ value
  )) %>% 
  mutate(IQR = IQR(value)) %>% 
  ungroup() %>% 
  distinct(metric, Q1, Q2, IQR)

SOI.df<-SOI.df %>% 
  mutate(SOI = (IQR/(Q1-Q2)))

metrics.drop.SOI <- SOI.df %>% 
  filter(SOI > 1) %>% 
  pull(metric)

# Investigating previously dropped metrics:
# metrics.drop.SOI_2 <- SOI.df %>% 
#   filter(SOI >= 1,
#          SOI <= 2) %>% 
#   pull(metric)
# 
# setdiff(metrics.drop.SOI_2, metrics.drop.SOI)
# setdiff(metrics.drop.SOI, metrics.drop.SOI_2)

```


## Summarize and remove underperforming metrics

```{r}

# Compile list of metrics to drop
metrics.drop <- c(metrics.drop.range, metrics.drop.SOI, metrics.drop.sim) %>% 
  unique()

train.df.final <- train.df %>% 
  select(site_id, condition_class, all_of(sensitive_mets.vec), -all_of(metrics.drop)) 
    
### OLD CODE:

# Metrics with poor range:
# rich_ttaxa_gammaridae, rich_ttaxa_baetidae,	pct_anisoptera,	pielou_ttaxa,	gini_simpson_ttaxa_ept,	simpson_ttaxa_gammaridae,	simpson_ttaxa_baetidae,	simpson_ttaxa_cot
# All are included below except pielou_ttaxa and simpson_ttaxa_cot


## Metrics with >50% same value: [26 unique]

# gini_simpson_ttaxa_ept, pct_anisoptera, pct_baetidae, pct_dubiraphia, pct_elmidae, pct_ep, pct_ephemeroptera, pct_furcatergalia, pct_gammaridae, pct_gammarus, pct_pisciforma, pct_pt, pct_rich_ttaxa_baetidae, pct_rich_ttaxa_ep, pct_rich_ttaxa_ephemeroptera, pct_rich_ttaxa_gammaridae, pct_tanytarsus, rich_ttaxa_baetidae, rich_ttaxa_ep, rich_ttaxa_ephemeroptera, rich_ttaxa_gammaridae, shannon_ttaxa_ephemeroptera, shannon_ttaxa_ept, shannon_ttaxa_intolerant, simpson_ttaxa_baetidae, simpson_ttaxa_gammaridae


# Poor SOI
#(>=1 & <=2): [15 unique]
# rich_ttaxa_toe, rich_ttaxa_ephemeroptera, shannon_ttaxa_ephemeroptera, rich_ttaxa_ep, rich_ttaxa_ept, rich_ttaxa_et, shannon_ttaxa_intolerant, rich_ttaxa_cote, rich_ttaxa_potec, rich_ttaxa_insecta, pct_rich_ttaxa_ep, rich_ttaxa_cot, pct_intolerant, pct_rich_ttaxa_baetidae, pct_rich_ttaxa_ephemeroptera, pct_rich_ttaxa_et, rich_ttaxa_intolerant, rich_ttaxa_baetidae, pct_rich_ttaxa_insecta, simpson_ttaxa_baetidae, pct_cot, pct_rich_ttaxa_ept, pct_insecta, pct_rich_ttaxa_intolerant


# 43 unique above, brings total from 62 down to 19.

# train.df.final_OLD <- train.df %>% 
#   select(site_id, condition_class,all_of(sensitive_mets.vec)) %>% 
#   # Removing metrics with poor ranges
#   select(-c(rich_ttaxa_gammaridae, rich_ttaxa_baetidae,	pct_anisoptera,	pielou_ttaxa,	gini_simpson_ttaxa_ept,	simpson_ttaxa_gammaridae,	simpson_ttaxa_baetidae,	simpson_ttaxa_cot)) %>% 
#   # Removing redundant metrics
#   select(-c(pct_baetidae, pct_dubiraphia, pct_elmidae, pct_ep, pct_ephemeroptera, pct_furcatergalia, pct_gammaridae, pct_gammarus, pct_pisciforma, pct_pt, pct_rich_ttaxa_baetidae, pct_rich_ttaxa_ep, pct_rich_ttaxa_ephemeroptera, pct_rich_ttaxa_gammaridae, pct_tanytarsus, rich_ttaxa_ep, rich_ttaxa_ephemeroptera, shannon_ttaxa_ephemeroptera, shannon_ttaxa_ept, shannon_ttaxa_intolerant)) %>% 
#   # Removing metrics based on SOI
#   select(-c(rich_ttaxa_toe, rich_ttaxa_ept, rich_ttaxa_et, rich_ttaxa_cote, rich_ttaxa_potec, rich_ttaxa_insecta, rich_ttaxa_cot, pct_intolerant, pct_rich_ttaxa_et, rich_ttaxa_intolerant, pct_rich_ttaxa_insecta, pct_cot, pct_rich_ttaxa_ept, pct_insecta, pct_rich_ttaxa_intolerant))
  # Remove further metrics based on high intercorrelations and visual inspecion (code chunks below)
  # (to be added)

```


```{r Redundancy by correlation, fig.width=8, fig.height=8}
library(corrr)

# Plot correlations of remaining metrics
# Bowman (yr?; GLIMPSS): "While there is no consensus on “hard cutoffs” for detecting metric redundancy, several workers have chosen r-values in excess of 0.75 (Maxted et al. 2000, Blocksom and Johnson 2009), 0.85 (Butcher et al. 2003, Gerritsen et al. 2000a), and 0.90 (Barbour et al. 1996) to screen for metric redundancy. For GLIMPSS development, we chose Pearson r-values of 0.75 as the cutoff"


corr.final<-train.df.final %>% 
  select(-condition_class, -site_id) %>% 
  correlate(use = "pairwise.complete.obs", method = "spearman") %>% 
  rearrange() %>% 
  shave()
corr.final_rownames <- corr.final %>%
  # mutate_all(~replace(., is.na(.), 1)) %>% 
  remove_rownames %>% 
  column_to_rownames(var="term")  
corr.final_highcorr <- corr.final_rownames %>%
  abs() %>% 
  round(digits = 3) %>% 
  rownames_to_column() %>%
  # Remove values < 0.9
  mutate_all(funs(replace(., . <= 0.75, NA))) %>%
  # Remove columns and rows with all NAs
  column_to_rownames() %>% 
  purrr::discard(~all(is.na(.))) %>% 
  filter_all(any_vars(!is.na(.)))
ggcorrplot::ggcorrplot(corr.final_rownames)

# Same as above for only cond class 1  (as per Shull et al. 2019)
corr.final.cc1 <-train.df.final %>% 
  filter(condition_class %in% "1") %>% 
  select(-condition_class, -site_id) %>% 
  correlate(use = "pairwise.complete.obs", method = "spearman") %>% 
  rearrange() %>% 
  shave()
corr.final_rownames.cc1 <- corr.final.cc1 %>%
  # mutate_all(~replace(., is.na(.), 1)) %>% 
  remove_rownames %>% 
  column_to_rownames(var="term")  
corr.final_highcorr.cc1 <- corr.final_rownames.cc1 %>%
  abs() %>% 
  round(digits = 3) %>% 
  rownames_to_column() %>%
  # Remove values < 0.9
  mutate_all(funs(replace(., . <= 0.75, NA))) %>%
  # Remove columns and rows with all NAs
  column_to_rownames() %>% 
  purrr::discard(~all(is.na(.))) %>% 
  filter_all(any_vars(!is.na(.)))
ggcorrplot::ggcorrplot(corr.final_rownames.cc1)



## LOOK AT SCATTERPLOTS OF THOSE W/ CORR'S ABOVE THRESHOLD to see if there are relationships other than linear (indicates duplicate metrics).
# Use psych package (see abiotic corr plots Rmd).

  # Shull et al. 2019: "Metrics with correlation coefficients > 0.75 were evaluated further by visually inspecting scatterplots. Candidate metrics with correlation coefficients > 0.75 and insufficient spread in the scatterplot were removed as candidate metrics."
 # Bowman: "...metric pairs approaching or slightly exceeding this value were further examined using scatterplots to see if nonlinear relationships were apparent or if there was sufficient dispersion (i.e., scatter) of the paired metric data points (Barbour et al. 1999). In this case, inclusion of both metrics could be beneficial to the multi-metric index."



```

```{r Table: highly correlated metrics}
DT::datatable(head(corr.final_highcorr.cc1, 500), options = list(scrollX = TRUE))

```


```{r Filtered metric boxplots, fig.width=12, fig.height=12}

# train.df.final.long <- train.df.final %>% 
#   pivot_longer(!c(site_id, condition_class), names_to = "metric", values_to="value")
# 
# train.df.final.long2 <- tidyr::gather(train.df.final, metric, value, -site_id, -condition_class)  #%>% 
  # left_join(condition.df, by = "bas_loc_rm")


# Get list of filtered metrics to this point
metrics.filt <- train.df.final %>% 
  select(-c(site_id, condition_class)) %>% 
  names() %>% 
  sort()

# metrics.filt_OLD <- train.df.final_OLD %>% 
#   select(-c(site_id, condition_class)) %>% 
#   names() %>% 
#   sort()

# setdiff(metrics.filt, metrics.filt_OLD)


sens.df %>% 
  filter(metric %in% metrics.filt) %>%
  # filter(barbour == 3) %>% 
  arrange(metric) %>% 
  inner_join(long.df, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric)),
         condition_class = factor(condition_class, levels = unique(condition_class))) %>% 
  ggplot(aes(condition_class, value)) +
  geom_boxplot() +
  facet_wrap(~metric, ncol = 4, scales = "free")

# sens.df %>% 
#   filter(metric %in% "rich_ffg") %>%
#   # filter(barbour == 3) %>% 
#   arrange(metric) %>% 
#   inner_join(long.df, by = "metric") %>% 
#   mutate(metric = factor(metric, levels = unique(metric)),
#          condition_class = factor(condition_class, levels = unique(condition_class))) %>% 
#   ggplot(aes(condition_class, value)) +
#   geom_boxplot() +
#   facet_wrap(~metric, ncol = 4, scales = "free")

```

```{r View sens table for filtered metrics, eval=TRUE}
sens.filt <- sens.df %>% 
  filter(metric %in% metrics.filt)

DT::datatable(head(sens.filt, 500), options = list(scrollX = TRUE))

# write.csv(sens.filt, "sens.filt.csv")
```


Select final metrics and plot

Removed rich_ttaxa_intol_facul for rich_ttaxa b/c say similar things but former has better DE. Removed  
```{r}

# BPJ...
# PROVISIONAL SELECTION v1
# metrics.final <- c("margalef_ttaxa", "shannon_ttaxa_cot", "rich_ttaxa", "pct_rich_ttaxa_cote", "dom_5_ttaxa", "pct_toe")

# PROVISIONAL SELECTION v2
### CHECK THESE IN CORR PLOT ###
metrics.final <- c("dom_5_ttaxa", "pct_rich_ttaxa_potec", "rich_ttaxa_ept", "rich_ttaxa_gatherer", "rich_ttaxa_intolerant", "margalef_ttaxa")





# train.df.final2 <- train.df %>% 
#   select(site_id, condition_class, all_of(metrics.final))
# 
# # Get list of filtered metrics to this point
# metrics.final <- train.df.final2 %>% 
#   select(-c(site_id, condition_class)) %>% 
#   names()


sens.df %>% 
  filter(metric %in% metrics.final) %>%
  # filter(barbour == 3) %>% 
  arrange(metric) %>% 
  inner_join(long.df, by = "metric") %>% 
  mutate(metric = factor(metric, levels = unique(metric)),
         condition_class = factor(condition_class, levels = unique(condition_class))) %>% 
  ggplot(aes(condition_class, value)) +
  geom_boxplot() +
  facet_wrap(~metric, ncol = 4, scales = "free")

```

```{r Corr plot for final metrics}

train.df.final.corr <- train.df.final %>% 
  select(site_id, condition_class, all_of(metrics.final))

corr.finalfinal.cc1 <-train.df.final.corr %>% 
  filter(condition_class %in% "1") %>% 
  select(-condition_class, -site_id) %>% 
  correlate(use = "pairwise.complete.obs", method = "spearman") %>% 
  rearrange() %>% 
  shave()
corr.finalfinal_rownames.cc1 <- corr.finalfinal.cc1 %>%
  # mutate_all(~replace(., is.na(.), 1)) %>% 
  remove_rownames %>% 
  column_to_rownames(var="term")  
corr.finalfinal_highcorr.cc1 <- corr.finalfinal_rownames.cc1 %>%
  abs() %>% 
  round(digits = 3) %>% 
  rownames_to_column() %>%
  # Remove values < 0.9
  mutate_all(funs(replace(., . <= 0.75, NA))) %>%
  # Remove columns and rows with all NAs
  column_to_rownames() %>% 
  purrr::discard(~all(is.na(.))) %>% 
  filter_all(any_vars(!is.na(.)))
ggcorrplot::ggcorrplot(corr.finalfinal_rownames.cc1)
```

# Traditional IBI method

```{r Standardizing metrics}

# Adapt code from matt, look at old LG script.

```




#Training and Logistical Regression model

```{r Data prep and model creation}

# Packages at https://www.tidymodels.org/

# Create recipe object
rec_obj <- train_sensitive.df %>% 
  select(condition_class, all_of(metrics.final)) %>% 
  recipe(condition_class ~ ., data = .) %>% 
  # update_role(uniqueid, new_role = "sample_id") %>%
  step_normalize(all_predictors()) %>% 
 # step_nzv(all_predictors()) %>%
 # step_corr(all_predictors(),
  #          threshold = 0.5) %>%
 # step_pca(all_predictors()) %>%
  themis::step_smote(condition_class)
  # step_smote creates a specification of a recipe step that generate new examples of the minority class using nearest neighbors of these cases.
  # Matt says step_smote is redundant if already balanced btw test and ref sites... but removing does not result in an identical DF!


# Extract finalized training set (juice function). Specifiy params for log regr. and engine.

train.juice <- rec_obj %>% 
  prep(training = train_sensitive.df) %>% 
  juice()

logit_mod <- logistic_reg() %>%
  set_engine("stan")

met.flow <- workflow() %>% 
  add_recipe(rec_obj) %>% 
  add_model(logit_mod)

# Provisional set # 1 - Outputs weighting coefficients of metrics used... margalef_ttaxa heavily weighted!!!
(fit_train <- fit(met.flow, data = train_sensitive.df))

```


```{r Cross validation and measuring performace}

# Cross validation tutorial: https://www.youtube.com/watch?v=fSytzGwwBVw 

library(tune)
library(yardstick)

# Training

control <- control_resamples(save_pred = FALSE)
metrics <- metric_set(roc_auc, bal_accuracy, pr_auc)

spline_res <- fit_resamples(logit_mod, rec_obj, train_10cv.df,
                            metrics = metrics,
                            control = control)

show_best(spline_res, metric = "roc_auc")
show_best(spline_res, metric = "bal_accuracy")
show_best(spline_res, metric = "pr_auc")

# Output scores (mean) of 1 would be 100% accurate classification. Zach says anything >75 acceptible (reference?).


# Validation (using test dataset) - dont need bc doing independent validation in confusion matrix below.

control <- control_resamples(save_pred = FALSE)
metrics <- metric_set(roc_auc, bal_accuracy, pr_auc)

spline_res <- fit_resamples(logit_mod, rec_obj, test_10cv.df,
                            metrics = metrics,
                            control = control)

show_best(spline_res, metric = "roc_auc")
show_best(spline_res, metric = "bal_accuracy")
show_best(spline_res, metric = "pr_auc")

```

```{r Create logistical regression model}

test.df <- testing(train_test_split) %>% 
  filter(condition_class %in% c("1", "3")) %>% 
   select(condition_class, all_of(metrics.final))

#Training
pred_test <- predict(fit_train, new_data = train_sensitive.df, type = "prob") %>% 
  bind_cols(select(train_sensitive.df, condition_class))

# Validation (don't need this bc doing independent validation in confusion matrix below.)
pred_test_validation <- predict(fit_train, new_data = test.df, type = "prob") %>% 
  bind_cols(select(test.df, condition_class))
pred_test_all <- predict(fit_train, new_data = metrics.df, type = "prob") %>% 
  bind_cols(select(metrics.df, condition_class))


```


```{r Logistical regression model plots}

# Training

pred_test %>% 
  # filter(condition_class %in% c("1", "4")) %>% 
  mutate(condition_class = as.character(condition_class)) %>% 
  mutate(condition = case_when(
    condition_class %in% "3" ~ 1,
    condition_class %in% "1" ~ 0,
    TRUE ~ 9999
  )) %>% 
ggplot(aes(.pred_1, condition)) +
  geom_point() +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial)) 

# Validation (not needed; just plotting for visual comparison)

pred_test_validation %>% 
  # filter(condition_class %in% c("1", "4")) %>% 
  mutate(condition_class = as.character(condition_class)) %>% 
  mutate(condition = case_when(
    condition_class %in% "3" ~ 1,
    condition_class %in% "1" ~ 0,
    TRUE ~ 9999
  )) %>% 
ggplot(aes(.pred_1, condition)) +
  geom_point() +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial)) 

#All Data (not needed; just plotting for visual comparison)

pred_test_all %>% 
  filter(condition_class %in% c("1", "3")) %>% 
  mutate(condition_class = as.character(condition_class)) %>% 
  mutate(condition = case_when(
    condition_class %in% "3" ~ 1,
    condition_class %in% "1" ~ 0,
    TRUE ~ 9999
  )) %>% 
ggplot(aes(.pred_1, condition)) +
  geom_point() +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial)) 

```

```{r Visualize model performance (ROC curve)}

# Receiver operator curve
# Add in resampling as shown at https://yardstick.tidymodels.org/ ?
# Look up sensitivity vs specificity

# Training
# Goal is for model to have high sensitivity ("curve" tighter to top left corner). 


simple_glm_roc <- pred_test %>% 
  roc_curve(factor(condition_class), .pred_1)
# computes the area under the ROC curve
pred_test_validation %>% 
  roc_auc(factor(condition_class), .pred_1)
autoplot(simple_glm_roc)


# Validation (not needed?; just plotting for visual comparison)

simple_glm_roc <- pred_test_validation %>% 
  roc_curve(factor(condition_class), .pred_1)
pred_test_validation %>% 
  roc_auc(factor(condition_class), .pred_1)
autoplot(simple_glm_roc)



```

## Probilities from log regr. for each class - Summary of results!

```{r Log regr boxplot}


# ***Training***

train.df <- predict(fit_train, new_data = training(train_test_split), type = "prob") %>% 
  bind_cols(select(training(train_test_split), condition_class))

train.df %>% 
  mutate(condition_class = factor(condition_class, c("1", "2", "3"))) %>% 
ggplot(aes(condition_class, .pred_1)) +
  geom_boxplot()


#Validation

test.df <- predict(fit_train, new_data = testing(train_test_split), type = "prob") %>% 
  bind_cols(select(testing(train_test_split), condition_class, site_id))

test.df %>% 
  mutate(condition_class = factor(condition_class, c("1", "2", "3"))) %>% 
ggplot(aes(condition_class, .pred_1)) +
  geom_boxplot()

#All Data 

all.df <- predict(fit_train, new_data = metrics.df, type = "prob") %>% 
  bind_cols(select(metrics.df, condition_class, site_id))

all.df %>% 
  mutate(condition_class = factor(condition_class, c("1", "2", "3"))) %>% 
ggplot(aes(condition_class, .pred_1)) +
  geom_boxplot()

### LOOK AT OUTLIERS
all.df.outliers.cl3 <- all.df %>% 
  filter(condition_class == 3,
         .pred_1 > 0.5) %>% 
  pull(site_id)

all.df.outliers.cl1 <- all.df %>% 
  filter(condition_class == 1,
         .pred_1 < 0.25) %>% 
  pull(site_id)

outliers <- c(all.df.outliers.cl3, all.df.outliers.cl1) %>% 
  cat(sep = "\n")



```

```{r, confusion matrix accuracy assessment for validation dataset}

test.df <- predict(fit_train, new_data = testing(train_test_split), type = "prob") %>% 
  bind_cols(select(testing(train_test_split), condition_class, site_id))

# Assign prediction probabilities 
test.df.confuse<-test.df %>% 
  mutate(condition_class = factor(condition_class, c("1","3"))) %>%
  filter(condition_class %in% c("1","3")) %>% 
  mutate(prediction = case_when(
    .pred_1>0.5 ~ "1",
    .pred_1<0.5 ~ "3",
  )) %>% 
  rename(truth = condition_class) %>% 
  mutate(prediction = factor(prediction, c("1","3")))
  

test.df.confuse %>%
  conf_mat(truth, prediction) %>%
  summary() %>%
  filter(.metric %in%
    c("accuracy", "precision", "recall", "f_meas")) %>%
  as_tibble()
  
```




# ADAPT FROM MATT'S CODE


```{r plot params and probability binary classes}

# Test

all_abiotic_classified <- read_csv(file.path(here::here(),
                                             "data",
                                             "all.abiotic.classified.chem.watershed.csv"))
all_abiotic_classified<-all_abiotic_classified %>% 
  rename(uniqueid = uniqueID)


test.df.stressors<-left_join(test.df, all_abiotic_classified, by=c("uniqueid"))

test.df.stressors<-test.df.stressors %>% 
  select(uniqueid,.pred_1, ALK, NH3, CHLA,SECCHI, TKN, NOx, PH, COND, TN, TP, DEV, IMPERV, FOREST, NATURAL, AGRI, PC1) %>% 
  mutate(prediction = case_when(
    .pred_1 > 0.5 ~ "above_50",
    .pred_1 < 0.5 ~ "below_50",
    
  ))

all_abiotic_classified <- read_csv(file.path(here::here(),
                                             "data",
                                             "all.abiotic.classified.chem.watershed.csv"))
all_abiotic_classified<-all_abiotic_classified %>% 
  rename(uniqueid = uniqueID)


test.df.stressors<-left_join(test.df, all_abiotic_classified, by=c("uniqueid"))

test.df.stressors<-test.df.stressors %>% 
  filter(condition_class %in%c("1","3")) %>% 
  select(uniqueid,.pred_1, ALK, NH3, CHLA,SECCHI, TKN, NOx, PH, COND, TN, TP, DEV, IMPERV, FOREST, NATURAL, AGRI, PC1) %>% 
  mutate(prediction = case_when(
    .pred_1 > 0.5 ~ "above_50",
    .pred_1 < 0.5 ~ "below_50",
    
  ))

test.df.stressors.long<-test.df.stressors %>% 
  select(-prediction, -.pred_1) %>% 
  pivot_longer(!uniqueid, values_to = "value", names_to = "parameter")


test.df.stressor.class<-test.df.stressors %>% 
  select(uniqueid, prediction)

test.df.stressors.long<-left_join(test.df.stressors.long, test.df.stressor.class, by=c("uniqueid"))



q <- test.df.stressors.long %>% 
  ggplot(aes(prediction, value)) + geom_boxplot()

q + facet_wrap(vars(parameter), scales = "free")


# All Sites

all_abiotic_classified <- read_csv(file.path(here::here(),
                                             "data",
                                             "all.abiotic.classified.chem.watershed.csv"))
all_abiotic_classified<-all_abiotic_classified %>% 
  rename(uniqueid = uniqueID)


all.df.stressors<-left_join(all.df, all_abiotic_classified, by=c("uniqueid"))

all.df.stressors<-all.df.stressors %>% 
  select(uniqueid,.pred_1, ALK, NH3, CHLA,SECCHI, TKN, NOx, PH, COND, TN, TP, DEV, IMPERV, FOREST, NATURAL, AGRI, PC1) %>% 
  mutate(prediction = case_when(
    .pred_1 > 0.5 ~ "above_50",
    .pred_1 < 0.5 ~ "below_50",
    
  ))

all_abiotic_classified <- read_csv(file.path(here::here(),
                                             "data",
                                             "all.abiotic.classified.chem.watershed.csv"))
all_abiotic_classified<-all_abiotic_classified %>% 
  rename(uniqueid = uniqueID)


all.df.stressors<-left_join(all.df, all_abiotic_classified, by=c("uniqueid"))

all.df.stressors<-all.df.stressors %>% 
  #filter(condition_class %in%c("1","3")) %>% 
  select(uniqueid,.pred_1, ALK, NH3, CHLA,SECCHI, TKN, NOx, PH, COND, TN, TP, DEV, IMPERV, FOREST, NATURAL, AGRI, PC1) %>% 
  mutate(prediction = case_when(
    .pred_1 > 0.5 ~ "above_50",
    .pred_1 < 0.5 ~ "below_50",
    
  ))

all.df.stressors.long<-all.df.stressors %>% 
  select(-prediction, -.pred_1) %>% 
  pivot_longer(!uniqueid, values_to = "value", names_to = "parameter")


all.df.stressor.class<-all.df.stressors %>% 
  select(uniqueid, prediction)

all.df.stressors.long<-left_join(all.df.stressors.long, all.df.stressor.class, by=c("uniqueid"))

all.df.stressors.median<-all.df.stressors.long %>% 
  group_by(parameter, prediction) %>% 
  summarise(median = median(value), 
            q25 = quantile(value, probs = 0.25),
            q75 = quantile(value, probs = 0.75))


q <- all.df.stressors.long %>% 
  ggplot(aes(prediction, value)) + geom_boxplot()

q + facet_wrap(vars(parameter), scales = "free")






all.df.stressors.long %>% 
  filter(parameter == "SECCHI") %>% 
  ggplot(aes(prediction, value)) + geom_boxplot()+geom_hline(yintercept = 2)+
  ylab("Secchi Depth (m)")

all.df.stressors.long %>% 
  filter(parameter == "TP") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+geom_hline(yintercept = 20)+
  coord_cartesian(ylim=c(0, 100))+
  ylab("TP (ug/L)")

all.df.stressors.long %>% 
  filter(parameter == "CHLA") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+geom_hline(yintercept = 8)+
  coord_cartesian(ylim=c(0, 100))+
  ylab("Chlorophyll-a (ug/L)")

all.df.stressors.long %>% 
  filter(parameter == "COND") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 1000))+
  ylab("Specific Conductance (us/cm)")


all.df.stressors.long %>% 
  filter(parameter == "NATURAL") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 100))+
  ylab("Watershed Natural Land Cover (%)")

all.df.stressors.long %>% 
  filter(parameter == "FOREST") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 100))+
  ylab("Watershed Forest Land Cover (%)")

all.df.stressors.long %>% 
  filter(parameter == "IMPERV") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 60))+
  ylab("Watershed Mean Impervious Cover (%)")

all.df.stressors.long %>% 
  filter(parameter == "DEV") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 100))+
  ylab("Watershed Developed Land Cover (%)")

all.df.stressors.long %>% 
  filter(parameter == "AGRI") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 100))+
  ylab("Watershed Agricultural Land Cover (%)")

all.df.stressors.long %>% 
  filter(parameter == "PH") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(5, 10))+
  ylab("pH")

all.df.stressors.long %>% 
  filter(parameter == "NOx") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 1000))+
  ylab("NOx (ug/L)")

all.df.stressors.long %>% 
  filter(parameter == "TN") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 2500))+
  ylab("TN (ug/L)")

all.df.stressors.long %>% 
  filter(parameter == "TKN") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 2500))+
  ylab("TKN (ug/L)")

all.df.stressors.long %>% 
  filter(parameter == "ALK") %>% 
   ggplot(aes(prediction, value)) + geom_boxplot()+
  coord_cartesian(ylim=c(0, 150))+
  ylab("Alkalinity (mg/L CaCO3)")

```




# Plot individual and sensitive metrics (ALREADY DONE IN CHUNK 27)

```{r Plot metrics}

### SCRIPT STOPS AT CODE BELOW ###

train.df %>% 
  mutate(condition_class = factor(condition_class, c("1", "2", "3"))) %>% 
ggplot(aes(condition_class, rich_genus)) +
  geom_boxplot()



train.df.sensitive<-train.df %>% 
   select(uniqueid, condition_class,all_of(sensitive_mets.vec))
  

train.df.long<-train.df.sensitive %>%
  select(-condition_class) %>% 
  pivot_longer(!uniqueid, values_to = "value", names_to = "metric")

train.df.class<-train.df %>% 
  select(uniqueid, condition_class)

train.df.long<-left_join(train.df.long, train.df.class, by=c("uniqueid"))


p <- train.df.long %>% 
  mutate(condition_class = factor(condition_class, c("1", "2", "3"))) %>%  
  ggplot(aes(condition_class, value)) + geom_boxplot()

p + facet_wrap(vars(metric), scales = "free")



metrics.df.sensitive<-metrics.df %>% 
   select(uniqueid, condition_class,all_of(sensitive_mets.vec))
  

metrics.df.long<-metrics.df.sensitive %>%
  select(-condition_class) %>% 
  pivot_longer(!uniqueid, values_to = "value", names_to = "metric")

metrics.df.class<-metrics.df %>% 
  select(uniqueid, condition_class)

metrics.df.long<-left_join(metrics.df.long, metrics.df.class, by=c("uniqueid"))

s <- metrics.df.long %>% 
  mutate(condition_class = factor(condition_class, c("1", "2", "3"))) %>%  
  ggplot(aes(condition_class, value)) + geom_boxplot()

s + facet_wrap(vars(metric), scales = "free")






```